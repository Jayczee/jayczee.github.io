import{_ as p}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,b as a,a as r,d as n,e as l,w as o,r as c,o as i}from"./app-C39gAUso.js";const D={};function d(y,s){const e=c("RouteLink");return i(),t("div",null,[a("p",null,[s[1]||(s[1]=n("在 Nginx 中，可以将各个服务使用不同的二级域名反向代理到公网，配合防火墙仅暴露服务器的小部分端口，从而提高安全性。💡 PS：当初年少不懂事，曾将所有端口暴露到公网，包括 ")),l(e,{to:"/nas/basic/9-v2rayn.html"},{default:o(()=>s[0]||(s[0]=[n("V2rayN 代理")])),_:1,__:[0]}),s[2]||(s[2]=n(" 服务，结果被某位法国大兄弟在短短三四个小时内吸干了机场流量。想想自己当初将代理端口无加密暴露到公网，真是个狼人的操作。🐺"))]),s[6]||(s[6]=a("h2",{id:"🚀-通过-portainer-stacks-安装-nginx",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#🚀-通过-portainer-stacks-安装-nginx"},[a("span",null,"🚀 通过 Portainer Stacks 安装 Nginx")])],-1)),a("p",null,[s[4]||(s[4]=n("与 ")),l(e,{to:"/nas/basic/3-ddns-go.html"},{default:o(()=>s[3]||(s[3]=[n("DDNS-GO")])),_:1,__:[3]}),s[5]||(s[5]=n(" 中的做法相同，采用在 Portainer Stacks 中添加 Docker Compose 文件的方式部署 Nginx 容器。以下是 Docker Compose 文件的示例："))]),s[7]||(s[7]=r(`<div class="language-bash" data-highlighter="shiki" data-ext="bash" data-title="bash" style="background-color:#1E1E1E;color:#D4D4D4;"><pre class="shiki dark-plus vp-code"><code><span class="line"><span style="color:#DCDCAA;">services:</span></span>
<span class="line"><span style="color:#DCDCAA;">  nginx:</span></span>
<span class="line"><span style="color:#DCDCAA;">    restart:</span><span style="color:#CE9178;"> always</span></span>
<span class="line"><span style="color:#DCDCAA;">    container_name:</span><span style="color:#CE9178;"> nginx</span></span>
<span class="line"><span style="color:#DCDCAA;">    image:</span><span style="color:#CE9178;"> nginx</span></span>
<span class="line"><span style="color:#DCDCAA;">    volumes:</span></span>
<span class="line"><span style="color:#DCDCAA;">      -</span><span style="color:#CE9178;"> /etc/nginx/conf.d:/etc/nginx/conf.d</span></span>
<span class="line"><span style="color:#DCDCAA;">      -</span><span style="color:#CE9178;"> /etc/nginx/nginx.conf:/etc/nginx/nginx.conf</span></span>
<span class="line"><span style="color:#DCDCAA;">      -</span><span style="color:#CE9178;"> /etc/letsencrypt:/etc/letsencrypt</span></span>
<span class="line"><span style="color:#DCDCAA;">      -</span><span style="color:#CE9178;"> /var/log/nginx:/var/log/nginx</span></span>
<span class="line"><span style="color:#DCDCAA;">    environment:</span></span>
<span class="line"><span style="color:#DCDCAA;">      -</span><span style="color:#CE9178;"> NGINX_PORT=</span><span style="color:#B5CEA8;">80</span></span>
<span class="line"><span style="color:#DCDCAA;">      -</span><span style="color:#CE9178;"> TZ=Asia/Shanghai</span></span>
<span class="line"><span style="color:#DCDCAA;">    privileged:</span><span style="color:#569CD6;"> true</span></span>
<span class="line"><span style="color:#DCDCAA;">    network_mode:</span><span style="color:#CE9178;"> host</span></span></code></pre></div><h3 id="📜-文件中参数定义如下" tabindex="-1"><a class="header-anchor" href="#📜-文件中参数定义如下"><span>📜 文件中参数定义如下：</span></a></h3><ol><li><strong>重启策略</strong>：设置为 <code>always</code>，表示如果容器停止，Docker 会自动重启它。</li><li><strong>容器名称</strong>：指定容器的名称为 <code>nginx</code>。</li><li><strong>镜像</strong>：使用官方的 <code>nginx</code> 镜像。</li><li><strong>挂载卷</strong>： <ul><li>将主机的 <code>/etc/nginx/conf.d</code> 目录挂载到容器的 <code>/etc/nginx/conf.d</code>，用于配置文件。</li><li>将主机的 <code>/etc/nginx/nginx.conf</code> 文件挂载到容器的 <code>/etc/nginx/nginx.conf</code>，用于主配置文件。</li><li>将主机的 <code>/etc/letsencrypt</code> 目录挂载到容器的 <code>/etc/letsencrypt</code>，用于 SSL 证书。</li><li>将主机的 <code>/var/log/nginx</code> 目录挂载到容器的 <code>/var/log/nginx</code>，用于日志文件。</li></ul></li><li><strong>环境变量</strong>： <ul><li><code>NGINX_PORT</code> 设置为 80，指定 Nginx 监听的端口。</li><li><code>TZ</code> 设置为 <code>Asia/Shanghai</code>，指定时区。</li></ul></li><li><strong>特权模式</strong>：设置为 <code>true</code>，允许容器获得额外的权限。</li><li><strong>网络模式</strong>：设置为 <code>host</code>，表示容器将使用主机的网络栈，容器和主机共享网络。</li></ol><p>与其他镜像不同的是，部署 Nginx 容器时，容器中并没有一个 <code>/etc/nginx/nginx.conf</code> 主配置文件（大部分镜像都会存在一个默认配置文件，直接将其映射到宿主机，在其基础上进行修改）。在此情况下，若直接部署 Nginx 镜像，容器会报错配置文件不存在。因此，需要在宿主机上创建一个主配置文件，并将其映射到容器内部。</p><h3 id="💡-tips" tabindex="-1"><a class="header-anchor" href="#💡-tips"><span>💡 Tips</span></a></h3><p>当宿主机的 A 文件（文件夹）与容器的 B 文件（文件夹）创建映射关系时，可能产生的结果如下：</p><ol><li><strong>A存在，B不存在</strong>：Docker 会在容器内创建一个空目录 B，并将宿主机的 A 目录挂载到 B 上。容器内的 B 目录将显示 A 的内容。</li><li><strong>A存在，B存在</strong>：Docker 会将宿主机的 A 目录挂载到容器内的 B 目录，容器内的 B 目录内容将与宿主机的 A 目录相同。容器内 B 的原有内容将被隐藏，但不会删除。</li><li><strong>A不存在，B不存在</strong>：Docker 会在容器内创建一个空目录 B，因为没有宿主机的 A 进行挂载。</li><li><strong>A不存在，B存在</strong>：容器内的 B 目录将保持不变，Docker 不会对其进行任何操作，B 的内容不会与宿主机的 A 进行关联。</li></ol><h3 id="🔑-总结" tabindex="-1"><a class="header-anchor" href="#🔑-总结"><span>🔑 总结</span></a></h3><p>挂载时，宿主机的目录优先级高于容器内的目录，宿主机的内容会覆盖容器内的内容。</p><h3 id="📝-创建配置文件-etc-nginx-nginx-conf" tabindex="-1"><a class="header-anchor" href="#📝-创建配置文件-etc-nginx-nginx-conf"><span>📝 创建配置文件 <code>/etc/nginx/nginx.conf</code></span></a></h3><div class="language-bash" data-highlighter="shiki" data-ext="bash" data-title="bash" style="background-color:#1E1E1E;color:#D4D4D4;"><pre class="shiki dark-plus vp-code"><code><span class="line"><span style="color:#DCDCAA;">worker_processes</span><span style="color:#CE9178;"> auto</span><span style="color:#D4D4D4;">;</span></span>
<span class="line"><span style="color:#DCDCAA;">events</span><span style="color:#CE9178;"> {</span></span>
<span class="line"><span style="color:#DCDCAA;">        worker_connections</span><span style="color:#B5CEA8;"> 768</span><span style="color:#D4D4D4;">;</span></span>
<span class="line"><span style="color:#6A9955;">        # multi_accept on;</span></span>
<span class="line"><span style="color:#D4D4D4;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#DCDCAA;">http</span><span style="color:#CE9178;"> {</span></span>
<span class="line"><span style="color:#DCDCAA;">        sendfile</span><span style="color:#CE9178;"> on</span><span style="color:#D4D4D4;">;</span></span>
<span class="line"><span style="color:#DCDCAA;">        tcp_nopush</span><span style="color:#CE9178;"> on</span><span style="color:#D4D4D4;">;</span></span>
<span class="line"><span style="color:#DCDCAA;">        types_hash_max_size</span><span style="color:#B5CEA8;"> 2048</span><span style="color:#D4D4D4;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#DCDCAA;">        include</span><span style="color:#CE9178;"> /etc/nginx/mime.types</span><span style="color:#D4D4D4;">;</span></span>
<span class="line"><span style="color:#DCDCAA;">        default_type</span><span style="color:#CE9178;"> application/octet-stream</span><span style="color:#D4D4D4;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#DCDCAA;">        ssl_protocols</span><span style="color:#CE9178;"> TLSv1</span><span style="color:#CE9178;"> TLSv1.1</span><span style="color:#CE9178;"> TLSv1.2</span><span style="color:#CE9178;"> TLSv1.3</span><span style="color:#D4D4D4;">; </span><span style="color:#6A9955;"># Dropping SSLv3, ref: POODLE</span></span>
<span class="line"><span style="color:#DCDCAA;">        ssl_prefer_server_ciphers</span><span style="color:#CE9178;"> on</span><span style="color:#D4D4D4;">;</span></span>
<span class="line"><span style="color:#DCDCAA;">        client_max_body_size</span><span style="color:#CE9178;"> 8192M</span><span style="color:#D4D4D4;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#DCDCAA;">        include</span><span style="color:#CE9178;"> /etc/nginx/conf.d/</span><span style="color:#569CD6;">*</span><span style="color:#CE9178;">.conf</span><span style="color:#D4D4D4;">;</span></span>
<span class="line"><span style="color:#DCDCAA;">        include</span><span style="color:#CE9178;"> /etc/nginx/sites-enabled/</span><span style="color:#569CD6;">*</span><span style="color:#D4D4D4;">;</span></span>
<span class="line"><span style="color:#D4D4D4;">}</span></span></code></pre></div><h3 id="📂-创建文件夹-etc-nginx-conf-d" tabindex="-1"><a class="header-anchor" href="#📂-创建文件夹-etc-nginx-conf-d"><span>📂 创建文件夹 <code>/etc/nginx/conf.d</code></span></a></h3><p>在其中创建 <code>portainer.conf</code> 文件，写入如下内容：</p><div class="language-bash" data-highlighter="shiki" data-ext="bash" data-title="bash" style="background-color:#1E1E1E;color:#D4D4D4;"><pre class="shiki dark-plus vp-code"><code><span class="line"><span style="color:#DCDCAA;">upstream</span><span style="color:#CE9178;"> portainer</span><span style="color:#CE9178;"> {</span></span>
<span class="line"><span style="color:#DCDCAA;">    server</span><span style="color:#CE9178;"> localhost:9000</span><span style="color:#D4D4D4;">;</span></span>
<span class="line"><span style="color:#D4D4D4;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#DCDCAA;">server</span><span style="color:#CE9178;"> {</span></span>
<span class="line"><span style="color:#DCDCAA;">    listen</span><span style="color:#B5CEA8;">       12120</span><span style="color:#CE9178;"> ssl</span><span style="color:#D4D4D4;">; </span><span style="color:#6A9955;"># 端口</span></span>
<span class="line"><span style="color:#DCDCAA;">    server_name</span><span style="color:#CE9178;">  portainer.domain.com</span><span style="color:#D4D4D4;">; </span><span style="color:#6A9955;"># 二级域名改为 portainer</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A9955;">    # 证书</span></span>
<span class="line"><span style="color:#DCDCAA;">    ssl_certificate</span><span style="color:#CE9178;"> /etc/letsencrypt/live/domain.com/fullchain.pem</span><span style="color:#D4D4D4;">;</span></span>
<span class="line"><span style="color:#DCDCAA;">    ssl_certificate_key</span><span style="color:#CE9178;"> /etc/letsencrypt/live/domain.com/privkey.pem</span><span style="color:#D4D4D4;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#DCDCAA;">    ssl_session_timeout</span><span style="color:#CE9178;"> 5m</span><span style="color:#D4D4D4;">;</span></span>
<span class="line"><span style="color:#DCDCAA;">    ssl_protocols</span><span style="color:#CE9178;"> TLSv1</span><span style="color:#CE9178;"> TLSv1.1</span><span style="color:#CE9178;"> TLSv1.2</span><span style="color:#D4D4D4;">;</span></span>
<span class="line"><span style="color:#DCDCAA;">    ssl_ciphers</span><span style="color:#CE9178;"> ALL:!ADH:!EXPORT56:RC4+RSA:+HIGH:+MEDIUM:+LOW:+SSLv2:+EXP</span><span style="color:#D4D4D4;">;</span></span>
<span class="line"><span style="color:#DCDCAA;">    ssl_prefer_server_ciphers</span><span style="color:#CE9178;"> on</span><span style="color:#D4D4D4;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#DCDCAA;">    location</span><span style="color:#CE9178;"> /</span><span style="color:#CE9178;"> {</span></span>
<span class="line"><span style="color:#DCDCAA;">        proxy_http_version</span><span style="color:#B5CEA8;"> 1.1</span><span style="color:#D4D4D4;">;</span></span>
<span class="line"><span style="color:#DCDCAA;">        proxy_set_header</span><span style="color:#CE9178;"> Upgrade</span><span style="color:#9CDCFE;"> $http_upgrade</span><span style="color:#D4D4D4;">;</span></span>
<span class="line"><span style="color:#DCDCAA;">        proxy_set_header</span><span style="color:#CE9178;"> Connection</span><span style="color:#CE9178;"> &quot;upgrade&quot;</span><span style="color:#D4D4D4;">;</span></span>
<span class="line"><span style="color:#DCDCAA;">        proxy_pass</span><span style="color:#CE9178;"> http://portainer</span><span style="color:#D4D4D4;">;</span></span>
<span class="line"><span style="color:#D4D4D4;">    }</span></span>
<span class="line"><span style="color:#D4D4D4;">}</span></span></code></pre></div><h3 id="🔍-各部分的解释" tabindex="-1"><a class="header-anchor" href="#🔍-各部分的解释"><span>🔍 各部分的解释：</span></a></h3><ol><li><strong>upstream portainer</strong>: 定义了一个名为 <code>portainer</code> 的上游服务器，指向 <code>localhost:9002</code>，即 Portainer 服务运行的地址。</li><li><strong>server { ... }</strong>: 定义了一个 Nginx 服务器块，包含监听的端口和域名等配置。</li><li><strong>listen 12120 ssl;</strong>: 指定服务器监听 12120 端口，并启用 SSL。</li><li><strong>server_name <a href="http://portainer.domain.com" target="_blank" rel="noopener noreferrer">portainer.domain.com</a>;</strong>: 指定该服务器块的域名为 <code>portainer.domain.com</code>。</li><li><strong>ssl_certificate 和 ssl_certificate_key</strong>: 指定 SSL 证书和私钥的路径，用于加密 HTTPS 连接。</li><li><strong>ssl_session_timeout 5m;</strong>: 设置 SSL 会话的超时时间为 5 分钟。</li><li><strong>ssl_protocols 和 ssl_ciphers</strong>: 配置支持的 SSL/TLS 协议和加密套件，以增强安全性。</li><li><strong>location / { ... }</strong>: 配置了一个位置块，处理对根路径的请求。 <ul><li><strong>proxy_http_version 1.1;</strong>: 设置代理的 HTTP 版本为 1.1。</li><li><strong>proxy_set_header Upgrade $http_upgrade;</strong>: 设置 <code>Upgrade</code> 头，以支持 WebSocket。</li><li><strong>proxy_set_header Connection &quot;upgrade&quot;;</strong>: 设置 <code>Connection</code> 头，指示连接升级。</li><li><strong>proxy_pass <a href="http://portainer" target="_blank" rel="noopener noreferrer">http://portainer</a>;</strong>: 将请求转发到上游定义的 <code>portainer</code> 服务器。</li></ul></li></ol><p>总体来说，该配置文件将来自 <code>portainer.domain.com</code> 的 HTTPS 请求通过 Nginx 反向代理到本地的 Portainer 服务，并确保连接的安全性。🔒</p><h3 id="🔄-最后步骤" tabindex="-1"><a class="header-anchor" href="#🔄-最后步骤"><span>🔄 最后步骤</span></a></h3><p>在服务器上重启 Docker 中的 Nginx：</p><div class="language-bash" data-highlighter="shiki" data-ext="bash" data-title="bash" style="background-color:#1E1E1E;color:#D4D4D4;"><pre class="shiki dark-plus vp-code"><code><span class="line"><span style="color:#DCDCAA;">docker</span><span style="color:#CE9178;"> restart</span><span style="color:#CE9178;"> nginx</span></span></code></pre></div><p>访问 <code>https://portainer.domain.com:12120</code>，即可通过域名访问到 Portainer 容器。🌍</p><h3 id="📋-模板使用" tabindex="-1"><a class="header-anchor" href="#📋-模板使用"><span>📋 模板使用</span></a></h3><p>以上的 Portainer 容器反向代理配置文件可以作为一个模板，大部分服务都可以按照该模板进行配置。🛠️ 只有某些服务需要添加一些额外配置，这类服务在官方文档中一般都有说明，查找官方文档即可。</p>`,23))])}const h=p(D,[["render",d]]),A=JSON.parse(`{"path":"/nas/basic/5-nginx.html","title":"Nginx 反向代理","lang":"zh-CN","frontmatter":{"title":"Nginx 反向代理","order":5,"isOriginal":true,"category":["NAS"],"tag":["nginx","docker"],"description":"在 Nginx 中，可以将各个服务使用不同的二级域名反向代理到公网，配合防火墙仅暴露服务器的小部分端口，从而提高安全性。💡 PS：当初年少不懂事，曾将所有端口暴露到公网，包括 服务，结果被某位法国大兄弟在短短三四个小时内吸干了机场流量。想想自己当初将代理端口无加密暴露到公网，真是个狼人的操作。🐺 🚀 通过 Portainer Stacks 安装 ...","head":[["meta",{"property":"og:url","content":"https://jayczee.cn/nas/basic/5-nginx.html"}],["meta",{"property":"og:site_name","content":"Jayczee's Blog"}],["meta",{"property":"og:title","content":"Nginx 反向代理"}],["meta",{"property":"og:description","content":"在 Nginx 中，可以将各个服务使用不同的二级域名反向代理到公网，配合防火墙仅暴露服务器的小部分端口，从而提高安全性。💡 PS：当初年少不懂事，曾将所有端口暴露到公网，包括 服务，结果被某位法国大兄弟在短短三四个小时内吸干了机场流量。想想自己当初将代理端口无加密暴露到公网，真是个狼人的操作。🐺 🚀 通过 Portainer Stacks 安装 ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-01-15T06:15:38.000Z"}],["meta",{"property":"article:tag","content":"nginx"}],["meta",{"property":"article:tag","content":"docker"}],["meta",{"property":"article:modified_time","content":"2025-01-15T06:15:38.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Nginx 反向代理\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-01-15T06:15:38.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Jayczee\\",\\"url\\":\\"https://jayczee.cn\\"}]}"]]},"headers":[{"level":2,"title":"🚀 通过 Portainer Stacks 安装 Nginx","slug":"🚀-通过-portainer-stacks-安装-nginx","link":"#🚀-通过-portainer-stacks-安装-nginx","children":[{"level":3,"title":"📜 文件中参数定义如下：","slug":"📜-文件中参数定义如下","link":"#📜-文件中参数定义如下","children":[]},{"level":3,"title":"💡 Tips","slug":"💡-tips","link":"#💡-tips","children":[]},{"level":3,"title":"🔑 总结","slug":"🔑-总结","link":"#🔑-总结","children":[]},{"level":3,"title":"📝 创建配置文件 /etc/nginx/nginx.conf","slug":"📝-创建配置文件-etc-nginx-nginx-conf","link":"#📝-创建配置文件-etc-nginx-nginx-conf","children":[]},{"level":3,"title":"📂 创建文件夹 /etc/nginx/conf.d","slug":"📂-创建文件夹-etc-nginx-conf-d","link":"#📂-创建文件夹-etc-nginx-conf-d","children":[]},{"level":3,"title":"🔍 各部分的解释：","slug":"🔍-各部分的解释","link":"#🔍-各部分的解释","children":[]},{"level":3,"title":"🔄 最后步骤","slug":"🔄-最后步骤","link":"#🔄-最后步骤","children":[]},{"level":3,"title":"📋 模板使用","slug":"📋-模板使用","link":"#📋-模板使用","children":[]}]}],"git":{"createdTime":1736491706000,"updatedTime":1736921738000,"contributors":[{"name":"Jayczee","username":"Jayczee","email":"jayczee@yeah.net","commits":4,"url":"https://github.com/Jayczee"}]},"readingTime":{"minutes":4.5,"words":1349},"filePathRelative":"nas/basic/5-nginx.md","localizedDate":"2025年1月10日","excerpt":"<p>在 Nginx 中，可以将各个服务使用不同的二级域名反向代理到公网，配合防火墙仅暴露服务器的小部分端口，从而提高安全性。💡 PS：当初年少不懂事，曾将所有端口暴露到公网，包括 <a href=\\"/nas/basic/9-v2rayn.html\\" target=\\"_blank\\">V2rayN 代理</a> 服务，结果被某位法国大兄弟在短短三四个小时内吸干了机场流量。想想自己当初将代理端口无加密暴露到公网，真是个狼人的操作。🐺</p>\\n<h2>🚀 通过 Portainer Stacks 安装 Nginx</h2>\\n<p>与 <a href=\\"/nas/basic/3-ddns-go.html\\" target=\\"_blank\\">DDNS-GO</a> 中的做法相同，采用在 Portainer Stacks 中添加 Docker Compose 文件的方式部署 Nginx 容器。以下是 Docker Compose 文件的示例：</p>","autoDesc":true}`);export{h as comp,A as data};
