---
title: 《MySQL是怎样运行的：从根上理解MySQL》
category:
    - 学习笔记
tag:
    - MySQL
---

## 感谢原书作者

感谢原书作者的总结，原书地址：[原书地址](https://juejin.cn/book/6844733769996304392)

免费分享出来的Github Page：[Github Page](https://relph1119.github.io/mysql-learning-notes/#/)

有机会还是付费支持一下原作者，此处仅总结个人学习到的知识点，不展开说明。

## 第一章

1. **MySQL是C/S架构的**，默认使用TCP协议通信。
2. **mysqld**是服务端程序，可用于直接启动一个mysqld进程。
3. **mysqld_safe**是一个脚本，用于启动mysqld的同时启动一个守护进程，当mysqld挂掉时重启，还会将错误信息日志等重定向到别的文件中方便调查。
4. **mysql.server**间接调用mysql_safe，用于启动和停止MySQL服务器的脚本。
5. **mysql**用于启动客户端程序与服务端进行通信，启动参数可使用`-h`指定服务器地址，`-u`指定用户，`-p`指定密码。
6. **mysqld**启动时使用`-P`指定监听端口，同样客户端mysql启动时也可以使用`-P`指定服务端端口。
7. 服务端处理客户端查询请求大致分为**连接管理**、**解析与优化**、**存储引擎**三个部分，如下图: 

![MySQL客户端处理客户端请求](/assets/images/note/mysql/m-1.png)

8. 服务端与客户端建立连接后，服务端会创建一个线程处理该客户端的请求。当连接断开后，该线程会放入缓存，避免频繁创建与销毁线程带来的开销。
9. 连接创建后，需要经过解析与优化，分别是**查询缓存**、**语法解析**、**查询优化**。
10. 查询缓存只有查询语句SQL与先前的SQL一模一样时才有机会命中缓存，任何的不同都不会命中。
11. 包含某些系统函数（比如NOW）、用户自定义变量与函数以及系统表的SQL的查询结果不会被缓存。
12. 如果某表被更新，那么相关的缓存全都会失效。
13. 如果缓存未命中，则进入语法解析阶段。
14. 语法解析完成后进入查询优化，最终会生成一个执行计划。可以使用`EXPLAIN`命令查看。截止到目前为止尚未访问真实表。
15. **查询缓存**、**语法解析**、**查询优化**划分为**Mysql Server**的功能，而真实存取数据的功能划分为**存储引擎**的功能。各种存储引擎向**Mysql Server**层提供统一的调用接口（存储引擎API）。
16. **Mysql Server**完成查询优化后，根据生成的执行计划调用存储引擎API，直接返回数据。
17. Mysql存储引擎包含：

| 存储引擎   | 描述                                   |
|------------|----------------------------------------|
| ARCHIVE    | 用于数据存档（行被插入后不能再修改）   |
| BLACKHOLE  | 丢弃写操作，读操作会返回空内容         |
| CSV        | 在存储数据时，以逗号分隔各个数据项     |
| FEDERATED  | 用来访问远程表                         |
| InnoDB     | 具备外键支持功能的事务存储引擎         |
| MEMORY     | 置于内存的表                           |
| MERGE      | 用来管理多个MyISAM表构成的表集合      |
| MyISAM     | 主要的非事务处理存储引擎               |
| NDB        | MySQL集群专用存储引擎                   |

最常用的是**InnoDB**和**MyISAM**。

18. 存储引擎是负责对表中的数据进行提取和写入的，可以为不同的表设置不同的存储引擎。

## 第二章

1. `mysqld --skip-networking` 禁止客户端TCP/IP通信。
2. `mysqld --default-storage-engine=MyISAM` 设置默认存储引擎，未指定时默认为InnoDB。
3. 启动选项有长形式和短形式，例如`--host`等价于`-h`，使用短形式时选项名和选项值之间可以没有空格，`-p`除外。
4. 推荐使用配置文件来设置启动选项。
5. 配置文件内容格式如下：

    ```ini
    [server]
    (具体的启动选项...)

    [mysqld]
    (具体的启动选项...)

    [mysqld_safe]
    (具体的启动选项...)

    [client]
    (具体的启动选项...)

    [mysql]
    (具体的启动选项...)

    [mysqladmin]
    (具体的启动选项...)
    ```

   填写格式如下：

    ```ini
    [server]
    option1            # 这是option1，该选项不需要选项值
    option2 = value2   # 这是option2，该选项需要选项值
    ```

   也可以使用类命令行形式:

    ```bash
    --option1 --option2=value2
    ```

6. 启动命令会读取多个组的配置，具体如下：

| 启动命令        | 类别         | 能读取的组                          |
|-----------------|--------------|-------------------------------------|
| mysqld          | 启动服务器   | [mysqld]、[server]                  |
| mysqld_safe     | 启动服务器   | [mysqld]、[server]、[mysqld_safe]  |
| mysql.server     | 启动服务器   | [mysqld]、[server]、[mysql.server]  |
| mysql           | 启动客户端   | [mysql]、[client]                   |
| mysqladmin      | 启动客户端   | [mysqladmin]、[client]              |
| mysqldump       | 启动客户端   | [mysqldump]、[client]               |

7. 如果想指定mysql.server程序的启动参数，则必须将它们放在配置文件中，而不是放在命令行中。mysql.server仅支持start和stop作为命令行参数。
8. 选项组的名称后加上特定的MySQL版本号，比如对于[mysqld]选项组来说，可以定义一个[mysqld-5.7]的选项组，它的含义和[mysqld]一样，但只有版本号为5.7的mysqld程序才能使用这个选项组中的选项。
9. 如果在多个配置文件中设置了相同的启动选项，则以最后一个配置文件中的为准。需要参考配置文件优先级。
10. 在统一配置文件中，如果读取到的多个组包含同一启动项，将**以最后一个出现的组中的启动选项为准**。
11. 如果不希望mysql搜索默认路径的配置文件，则可以使用`--defaults-file`指定配置文件，没有则报错。
12. 同一个启动选项既出现在命令行中，又出现在配置文件中，则以命令行中的启动选项为准。
13. MySQL系统变量拥有作用范围`GLOBAL`和`SESSION`，即对全部客户端生效或对当前客户端生效。大部分系统变量可以在运行时使用SET命令动态修改。例如：

    ```sql
    SET SESSION default_storage_engine = MyISAM;
    ```

   不指定作用范围时，默认为`SESSION`。

14. `SHOW VARIABLES`查看的是`SESSION`范围的系统变量。可以通过`SHOW GLOBAL VARIABLES`查看`GLOBAL`范围的系统变量。
15. 如果某个客户端改变了某个系统变量在`GLOBAL`作用范围的值，并不会影响该系统变量在当前已经连接的客户端作用范围为`SESSION`的值，只会影响后续连入的客户端在作用范围为`SESSION`的值。
16. 并不是所有系统变量都具有`GLOBAL`和`SESSION`的作用范围。一些系统变量只具有`GLOBAL`作用范围，比如`max_connections`；一些系统变量只具有`SESSION`作用范围，比如`insert_id`；一些系统变量的值既具有`GLOBAL`作用范围，也具有`SESSION`作用范围，比如`default_storage_engine`；有些系统变量是只读的，并不能设置值，比如`version`。

## 第三章

1. **同一种字符集可以有多种比较规则**。
2. MySQL中的**utf8**是**utf8mb3**的缩写，**utf8mb3**是utf8字符集的阉割版，使用1~3个字节表示字符，**utf8mb4**才是正常的utf8字符集，使用1~4个字节表示字符。
3. 每种字符集对应若干种比较规则，每种字符集都有一种默认的比较规则。`SHOW COLLATION`的返回结果中的`Default`列的值为`YES`的就是该字符集的默认比较规则，比如utf8字符集默认的比较规则就是`utf8_general_ci`。
4. MySQL有4个级别的字符集和比较规则，分别是**服务器级别**、**数据库级别**、**表级别**与**列级别**。
5. 创建数据库时若不指定数据库字符集和比较规则，则使用服务器级别的值。
6. 单独修改字符集或比较规则时，只修改字符集，则比较规则将变为修改后的字符集默认的比较规则；只修改比较规则，则字符集将变为修改后的比较规则对应的字符集。
7. MySQL中字符的转换依靠**服务器解码时的字符集**`character_set_client`、**服务器将请求转换成目标字符集**`character_set_connection`以及**服务器返回结果的字符集**`character_set_results`三个系统变量。过程如下：

   ![MySQL字符集转换](/assets/images/note/mysql/m-2.png)

8. 可以使用`SET NAMES 字符集名`将上述三个系统变量一口气改为客户端字符集，这样可以省去转换过程。

## 第四章

1. **InnoDB**采取的方式是将数据划分为若干个页，以页作为磁盘和内存之间交互的基本单位，InnoDB中页的大小一般为16 KB。也就是说，在一般情况下，一次最少从磁盘中读取16 KB的内容到内存中，一次最少把内存中的16 KB内容刷新到磁盘中。
2. 记录在磁盘上的存放方式也被称为**行格式**或**记录格式**，分别有**Compact**、**Redundant**、**Dynamic**和**Compressed**行格式。
3. **Compact**格式结构如下：

   ![Compact 行格式结构](/assets/images/note/mysql/m-3.png)

   变长字段长度列表：变长字段即MySQL中`VARCHAR(M)`、`VARBINARY(M)`、各种`TEXT`类型、各种`BLOB`类型等长度不固定的类型的字段。变长字段中存储多少字节的数据是不固定的，所以在存储真实数据时需要顺便把这些数据占用的字节数也存起来。

   在Compact行格式中，把所有变长字段的真实数据占用的字节长度都存放在记录的开头部位，从而形成一个变长字段长度列表，各变长字段数据占用的字节数按照列的顺序**逆序存放**。

4. Compact行真实占用字节长度 = 字符长度 * 相应字符编码一个字符占用的字节数。
5. 变长字段长度列表中可能会用1个或2个字节来表示某个变长字段真实长度。若可变字段最大长度M<=255，则用1个字节表示（11111111）；若理论最大长度大于255，则看实际占用长度L，若L<=127则用1个字节，否则用2个字节。此处用127进行分割是因为有些字符可能需要两个字节来表示。判断一个字符是一个字节表示还是两个字节表示通过首位标志位是0是1来判断，0则为单字节字符，1则表示当前字节为整个字符的一半。
6. 并不是所有记录都有变长字段长度列表，变长字段长度列表仅存储非NULL值列的可变字段长度，若所有列都不是可变字段长度列或所有可变字段长度列都为NULL，则该部分就不需要。
7. 如果没有允许NULL值的列，那么NULL值列表也不存在。
8. 如果存在允许NULL值的列，每一列在NULL值列表中对应一个二进制位，也是逆序排序，若为0则该列为非NULL值，若为1则该列为NULL值。
9. MySQL规定NULL值列表必须用整数个字节表示，一个字节有8位，可以记录8列，若允许NULL值的列不足8列，则高位补0。

   ![NULL值列表高位补零](/assets/images/note/mysql/m-4.png)

10. 记录头由5个固定字节组成，即40位，代表着不同的含义：

   ![记录头结构](/assets/images/note/mysql/m-5.png)

   | 名称          | 大小（单位：bit） | 描述                                              |
   |---------------|-------------------|---------------------------------------------------|
   | 预留位1      | 1                 | 没有使用                                          |
   | 预留位2      | 1                 | 没有使用                                          |
   | delete_mask   | 1                 | 标记该记录是否被删除                              |
   | min_rec_mask  | 1                 | B+树的每层非叶子节点中的最小记录都会添加该标记 |
   | n_owned       | 4                 | 表示当前记录拥有的记录数                          |
   | heap_no       | 13                | 表示当前记录在记录堆的位置信息                  |
   | record_type   | 3                 | 表示当前记录的类型，0表示普通记录，1表示B+树非叶子节点记录，2表示最小记录，3表示最大记录 |
   | next_record   | 16                | 表示下一条记录的相对位置                          |

11. MySQL每条记录除了自己定义的数据列之外，还会有一些隐藏列：`DB_ROW_ID`（唯一标识行id）、`DB_TRX_ID`（事务id）、`DB_ROLL_PTR`（回滚指针）。
12. InnoDB表对主键的生成策略：优先使用用户自定义主键作为主键，如果用户没有定义主键，则选取一个Unique键作为主键，如果表中连Unique键都没有定义，InnoDB会为表默认添加一个名为`DB_ROW_ID`的隐藏列作为主键。因此，从上表中可以看出：InnoDB存储引擎会为每条记录添加`DB_TRX_ID`和`DB_ROLL_PTR`这两个列，但`DB_ROW_ID`是可选的（在没有自定义主键以及Unique键的情况下才会添加该列）。
13. 在Compact行格式中，加不加入**可变字段长度列表**还要参考当前的字符集，例如`char(n)`类型的字段，若使用`ascii`字符集，则其为定长字段列，但如果使用`utf8`，则该列中的字符可能是1个字节也可能是3个字节表示的，此时需要将长度存储到可变长度字段列表中。
14. **Redundant**格式行相比**Compressed**格式行，头部的**可变字段长度列表**变为**字段长度偏移列表**，用相邻两个数字的差值来表示各个字段（所有字段长度都会存储，包括隐藏列）的实际长度。
15. Redundant格式行的记录头由6个字节组成，即48位：

   | 名称               | 大小（单位：bit） | 描述                                                        |
   |--------------------|-------------------|-------------------------------------------------------------|
   | 预留位1           | 1                 | 没有使用                                                  |
   | 预留位2           | 1                 | 没有使用                                                  |
   | delete_mask        | 1                 | 标记该记录是否被删除                                      |
   | min_rec_mask       | 1                 | B+树的每层非叶子节点中的最小记录都会添加该标记         |
   | n_owned            | 4                 | 表示当前记录拥有的记录数                                  |
   | heap_no            | 13                | 表示当前记录在页面堆的位置信息                          |
   | n_field            | 10                | 表示记录中列的数量                                        |
   | 1byte_offs_flag    | 1                 | 标记字段长度偏移列表中每个列对应的偏移量是使用1字节还是2字节表示的 |
   | next_record        | 16                | 表示下一条记录的相对位置                                  |

16. **字段长度偏移列表**实质上是存储每个列中的值占用的空间在记录的真实数据处结束的位置，因此通过计算差值可以计算列长度。整条记录实际数据长度小于等于127（01111111），则用1个字节；大于127小于等于32767（0111111111111111），则用2个字节。超出之后存到溢出页，字段偏移长度表仅存储本页面上的偏移。
17. **字段长度偏移列表**无NULL值列表，列是否为NULL判断如下：当列是定长列时，将对应偏移量转为二进制，若第一位为1则该列值为NULL，其真实数据用0x00填充；若列为变长列，用偏移量减相邻值计算长度，若长度为0，则该列值为NULL。
18. Redundant格式行中，`char(n)`类型列真实数据空间始终为字符集格式最大长度 * n，例如utf8的`char(10)`就始终为30。
19. MySQL除了`BLOB`和`TEXT`，其他所有类型的一行（不包含记录头和隐藏列）总长不能超过65535个字节。
20. 在Compact和Redundant行格式中，对于占用存储空间非常大的列，在记录的真实数据处只会存储该列的一部分数据，把剩余的数据分散存储在几个其他的页中，然后记录的真实数据处用20个字节存储指向这些页的地址（当然这20个字节中还包括这些分散在其他页面中的数据的占用的字节数）。
21. 一个页一般是16KB，当记录中的数据太多，当前页放不下的时候，会把多余的数据存储到其他页中，这种现象称为**行溢出**。
22. Redundant行格式中，当某列数据非常长时，该行只会记录该列前*768字节*的数据，然后记录溢出页的地址。

   ![Redundant存储行数据](/assets/images/note/mysql/m-6.png)

   ![Redundant行格式](/assets/images/note/mysql/m-7.png)

23. 不只是`VARCHAR(M)`类型的列，其他的`TEXT`、`BLOB`类型的列在存储数据非常多的时候也会发生行溢出。
24. MySQL中要求一个页至少存储两行记录。
25. MySQL 5.7、8默认行格式是**Dynamic**。
26. **Dynamic**和**Compressed**行格式会把所有行溢出数据存储到其他页，原页面只记录页地址。**Compressed**会对页数据进行压缩。