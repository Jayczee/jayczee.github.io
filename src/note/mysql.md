---
title: 《MySQL是怎样运行的：从根上理解MySQL》
category:
    - 学习笔记
tag:
    - MySQL
---

## 感谢原书作者

感谢原书作者的总结，原书地址：[原书地址](https://juejin.cn/book/6844733769996304392)

免费分享出来的Github Page：[Github Page](https://relph1119.github.io/mysql-learning-notes/#/)

有机会还是付费支持一下原作者，此处仅总结个人学习到的知识点，不展开说明。

## 第一章

1. **MySQL是C/S架构的**，默认使用TCP协议通信。
2. **mysqld**是服务端程序，可用于直接启动一个mysqld进程。
3. **mysqld_safe**是一个脚本，用于启动mysqld的同时启动一个守护进程，当mysqld挂掉时重启，还会将错误信息日志等重定向到别的文件中方便调查。
4. **mysql.server**间接调用mysql_safe，用于启动和停止MySQL服务器的脚本。
5. **mysql**用于启动客户端程序与服务端进行通信，启动参数可使用`-h`指定服务器地址，`-u`指定用户，`-p`指定密码。
6. **mysqld**启动时使用`-P`指定监听端口，同样客户端mysql启动时也可以使用`-P`指定服务端端口。
7. 服务端处理客户端查询请求大致分为**连接管理**、**解析与优化**、**存储引擎**三个部分，如下图: 

![MySQL客户端处理客户端请求](/assets/images/note/mysql/m-1.png)

8. 服务端与客户端建立连接后，服务端会创建一个线程处理该客户端的请求。当连接断开后，该线程会放入缓存，避免频繁创建与销毁线程带来的开销。
9. 连接创建后，需要经过解析与优化，分别是**查询缓存**、**语法解析**、**查询优化**。
10. 查询缓存只有查询语句SQL与先前的SQL一模一样时才有机会命中缓存，任何的不同都不会命中。
11. 包含某些系统函数（比如NOW）、用户自定义变量与函数以及系统表的SQL的查询结果不会被缓存。
12. 如果某表被更新，那么相关的缓存全都会失效。
13. 如果缓存未命中，则进入语法解析阶段。
14. 语法解析完成后进入查询优化，最终会生成一个执行计划。可以使用`EXPLAIN`命令查看。截止到目前为止尚未访问真实表。
15. **查询缓存**、**语法解析**、**查询优化**划分为**Mysql Server**的功能，而真实存取数据的功能划分为**存储引擎**的功能。各种存储引擎向**Mysql Server**层提供统一的调用接口（存储引擎API）。
16. **Mysql Server**完成查询优化后，根据生成的执行计划调用存储引擎API，直接返回数据。
17. Mysql存储引擎包含：

| 存储引擎   | 描述                                   |
|------------|----------------------------------------|
| ARCHIVE    | 用于数据存档（行被插入后不能再修改）   |
| BLACKHOLE  | 丢弃写操作，读操作会返回空内容         |
| CSV        | 在存储数据时，以逗号分隔各个数据项     |
| FEDERATED  | 用来访问远程表                         |
| InnoDB     | 具备外键支持功能的事务存储引擎         |
| MEMORY     | 置于内存的表                           |
| MERGE      | 用来管理多个MyISAM表构成的表集合      |
| MyISAM     | 主要的非事务处理存储引擎               |
| NDB        | MySQL集群专用存储引擎                   |

最常用的是**InnoDB**和**MyISAM**。

18. 存储引擎是负责对表中的数据进行提取和写入的，可以为不同的表设置不同的存储引擎。

## 第二章

1. `mysqld --skip-networking` 禁止客户端TCP/IP通信。
2. `mysqld --default-storage-engine=MyISAM` 设置默认存储引擎，未指定时默认为InnoDB。
3. 启动选项有长形式和短形式，例如`--host`等价于`-h`，使用短形式时选项名和选项值之间可以没有空格，`-p`除外。
4. 推荐使用配置文件来设置启动选项。
5. 配置文件内容格式如下：

    ```ini
    [server]
    (具体的启动选项...)

    [mysqld]
    (具体的启动选项...)

    [mysqld_safe]
    (具体的启动选项...)

    [client]
    (具体的启动选项...)

    [mysql]
    (具体的启动选项...)

    [mysqladmin]
    (具体的启动选项...)
    ```

   填写格式如下：

    ```ini
    [server]
    option1            # 这是option1，该选项不需要选项值
    option2 = value2   # 这是option2，该选项需要选项值
    ```

   也可以使用类命令行形式:

    ```bash
    --option1 --option2=value2
    ```

6. 启动命令会读取多个组的配置，具体如下：

| 启动命令        | 类别         | 能读取的组                          |
|-----------------|--------------|-------------------------------------|
| mysqld          | 启动服务器   | [mysqld]、[server]                  |
| mysqld_safe     | 启动服务器   | [mysqld]、[server]、[mysqld_safe]  |
| mysql.server     | 启动服务器   | [mysqld]、[server]、[mysql.server]  |
| mysql           | 启动客户端   | [mysql]、[client]                   |
| mysqladmin      | 启动客户端   | [mysqladmin]、[client]              |
| mysqldump       | 启动客户端   | [mysqldump]、[client]               |

7. 如果想指定mysql.server程序的启动参数，则必须将它们放在配置文件中，而不是放在命令行中。mysql.server仅支持start和stop作为命令行参数。
8. 选项组的名称后加上特定的MySQL版本号，比如对于[mysqld]选项组来说，可以定义一个[mysqld-5.7]的选项组，它的含义和[mysqld]一样，但只有版本号为5.7的mysqld程序才能使用这个选项组中的选项。
9. 如果在多个配置文件中设置了相同的启动选项，则以最后一个配置文件中的为准。需要参考配置文件优先级。
10. 在统一配置文件中，如果读取到的多个组包含同一启动项，将**以最后一个出现的组中的启动选项为准**。
11. 如果不希望mysql搜索默认路径的配置文件，则可以使用`--defaults-file`指定配置文件，没有则报错。
12. 同一个启动选项既出现在命令行中，又出现在配置文件中，则以命令行中的启动选项为准。
13. MySQL系统变量拥有作用范围`GLOBAL`和`SESSION`，即对全部客户端生效或对当前客户端生效。大部分系统变量可以在运行时使用SET命令动态修改。例如：

    ```sql
    SET SESSION default_storage_engine = MyISAM;
    ```

   不指定作用范围时，默认为`SESSION`。

14. `SHOW VARIABLES`查看的是`SESSION`范围的系统变量。可以通过`SHOW GLOBAL VARIABLES`查看`GLOBAL`范围的系统变量。
15. 如果某个客户端改变了某个系统变量在`GLOBAL`作用范围的值，并不会影响该系统变量在当前已经连接的客户端作用范围为`SESSION`的值，只会影响后续连入的客户端在作用范围为`SESSION`的值。
16. 并不是所有系统变量都具有`GLOBAL`和`SESSION`的作用范围。一些系统变量只具有`GLOBAL`作用范围，比如`max_connections`；一些系统变量只具有`SESSION`作用范围，比如`insert_id`；一些系统变量的值既具有`GLOBAL`作用范围，也具有`SESSION`作用范围，比如`default_storage_engine`；有些系统变量是只读的，并不能设置值，比如`version`。

## 第三章

1. **同一种字符集可以有多种比较规则**。
2. MySQL中的**utf8**是**utf8mb3**的缩写，**utf8mb3**是utf8字符集的阉割版，使用1~3个字节表示字符，**utf8mb4**才是正常的utf8字符集，使用1~4个字节表示字符。
3. 每种字符集对应若干种比较规则，每种字符集都有一种默认的比较规则。`SHOW COLLATION`的返回结果中的`Default`列的值为`YES`的就是该字符集的默认比较规则，比如utf8字符集默认的比较规则就是`utf8_general_ci`。
4. MySQL有4个级别的字符集和比较规则，分别是**服务器级别**、**数据库级别**、**表级别**与**列级别**。
5. 创建数据库时若不指定数据库字符集和比较规则，则使用服务器级别的值。
6. 单独修改字符集或比较规则时，只修改字符集，则比较规则将变为修改后的字符集默认的比较规则；只修改比较规则，则字符集将变为修改后的比较规则对应的字符集。
7. MySQL中字符的转换依靠**服务器解码时的字符集**`character_set_client`、**服务器将请求转换成目标字符集**`character_set_connection`以及**服务器返回结果的字符集**`character_set_results`三个系统变量。过程如下：

   ![MySQL字符集转换](/assets/images/note/mysql/m-2.png)

8. 可以使用`SET NAMES 字符集名`将上述三个系统变量一口气改为客户端字符集，这样可以省去转换过程。

## 第四章

1. **InnoDB**采取的方式是将数据划分为若干个页，以页作为磁盘和内存之间交互的基本单位，InnoDB中页的大小一般为16 KB。也就是说，在一般情况下，一次最少从磁盘中读取16 KB的内容到内存中，一次最少把内存中的16 KB内容刷新到磁盘中。
2. 记录在磁盘上的存放方式也被称为**行格式**或**记录格式**，分别有**Compact**、**Redundant**、**Dynamic**和**Compressed**行格式。
3. **Compact**格式结构如下：

   ![Compact 行格式结构](/assets/images/note/mysql/m-3.png)

   变长字段长度列表：变长字段即MySQL中`VARCHAR(M)`、`VARBINARY(M)`、各种`TEXT`类型、各种`BLOB`类型等长度不固定的类型的字段。变长字段中存储多少字节的数据是不固定的，所以在存储真实数据时需要顺便把这些数据占用的字节数也存起来。

   在Compact行格式中，把所有变长字段的真实数据占用的字节长度都存放在记录的开头部位，从而形成一个变长字段长度列表，各变长字段数据占用的字节数按照列的顺序**逆序存放**。

4. Compact行真实占用字节长度 = 字符长度 * 相应字符编码一个字符占用的字节数。
5. 变长字段长度列表中可能会用1个或2个字节来表示某个变长字段真实长度。若可变字段最大长度M<=255，则用1个字节表示（11111111）；若理论最大长度大于255，则看实际占用长度L，若L<=127则用1个字节，否则用2个字节。此处用127进行分割是因为有些字符可能需要两个字节来表示。判断一个字符是一个字节表示还是两个字节表示通过首位标志位是0是1来判断，0则为单字节字符，1则表示当前字节为整个字符的一半。
6. 并不是所有记录都有变长字段长度列表，变长字段长度列表仅存储非NULL值列的可变字段长度，若所有列都不是可变字段长度列或所有可变字段长度列都为NULL，则该部分就不需要。
7. 如果没有允许NULL值的列，那么NULL值列表也不存在。
8. 如果存在允许NULL值的列，每一列在NULL值列表中对应一个二进制位，也是逆序排序，若为0则该列为非NULL值，若为1则该列为NULL值。
9. MySQL规定NULL值列表必须用整数个字节表示，一个字节有8位，可以记录8列，若允许NULL值的列不足8列，则高位补0。

   ![NULL值列表高位补零](/assets/images/note/mysql/m-4.png)

10. 记录头由5个固定字节组成，即40位，代表着不同的含义：

   ![记录头结构](/assets/images/note/mysql/m-5.png)

   | 名称          | 大小（单位：bit） | 描述                                              |
   |---------------|-------------------|---------------------------------------------------|
   | 预留位1      | 1                 | 没有使用                                          |
   | 预留位2      | 1                 | 没有使用                                          |
   | delete_mask   | 1                 | 标记该记录是否被删除                              |
   | min_rec_mask  | 1                 | B+树的每层非叶子节点中的最小记录都会添加该标记 |
   | n_owned       | 4                 | 表示当前记录拥有的记录数                          |
   | heap_no       | 13                | 表示当前记录在记录堆的位置信息                  |
   | record_type   | 3                 | 表示当前记录的类型，0表示普通记录，1表示B+树非叶子节点记录，2表示最小记录，3表示最大记录 |
   | next_record   | 16                | 表示下一条记录的相对位置                          |

11. MySQL每条记录除了自己定义的数据列之外，还会有一些隐藏列：`DB_ROW_ID`（唯一标识行id）、`DB_TRX_ID`（事务id）、`DB_ROLL_PTR`（回滚指针）。
12. InnoDB表对主键的生成策略：优先使用用户自定义主键作为主键，如果用户没有定义主键，则选取一个Unique键作为主键，如果表中连Unique键都没有定义，InnoDB会为表默认添加一个名为`DB_ROW_ID`的隐藏列作为主键。因此，从上表中可以看出：InnoDB存储引擎会为每条记录添加`DB_TRX_ID`和`DB_ROLL_PTR`这两个列，但`DB_ROW_ID`是可选的（在没有自定义主键以及Unique键的情况下才会添加该列）。
13. 在Compact行格式中，加不加入**可变字段长度列表**还要参考当前的字符集，例如`char(n)`类型的字段，若使用`ascii`字符集，则其为定长字段列，但如果使用`utf8`，则该列中的字符可能是1个字节也可能是3个字节表示的，此时需要将长度存储到可变长度字段列表中。
14. **Redundant**格式行相比**Compressed**格式行，头部的**可变字段长度列表**变为**字段长度偏移列表**，用相邻两个数字的差值来表示各个字段（所有字段长度都会存储，包括隐藏列）的实际长度。
15. Redundant格式行的记录头由6个字节组成，即48位：

   | 名称               | 大小（单位：bit） | 描述                                                        |
   |--------------------|-------------------|-------------------------------------------------------------|
   | 预留位1           | 1                 | 没有使用                                                  |
   | 预留位2           | 1                 | 没有使用                                                  |
   | delete_mask        | 1                 | 标记该记录是否被删除                                      |
   | min_rec_mask       | 1                 | B+树的每层非叶子节点中的最小记录都会添加该标记         |
   | n_owned            | 4                 | 表示当前记录拥有的记录数                                  |
   | heap_no            | 13                | 表示当前记录在页面堆的位置信息                          |
   | n_field            | 10                | 表示记录中列的数量                                        |
   | 1byte_offs_flag    | 1                 | 标记字段长度偏移列表中每个列对应的偏移量是使用1字节还是2字节表示的 |
   | next_record        | 16                | 表示下一条记录的相对位置                                  |

16. **字段长度偏移列表**实质上是存储每个列中的值占用的空间在记录的真实数据处结束的位置，因此通过计算差值可以计算列长度。整条记录实际数据长度小于等于127（01111111），则用1个字节；大于127小于等于32767（0111111111111111），则用2个字节。超出之后存到溢出页，字段偏移长度表仅存储本页面上的偏移。
17. **字段长度偏移列表**无NULL值列表，列是否为NULL判断如下：当列是定长列时，将对应偏移量转为二进制，若第一位为1则该列值为NULL，其真实数据用0x00填充；若列为变长列，用偏移量减相邻值计算长度，若长度为0，则该列值为NULL。
18. Redundant格式行中，`char(n)`类型列真实数据空间始终为字符集格式最大长度 * n，例如utf8的`char(10)`就始终为30。
19. MySQL除了`BLOB`和`TEXT`，其他所有类型的一行（不包含记录头和隐藏列）总长不能超过65535个字节。
20. 在Compact和Redundant行格式中，对于占用存储空间非常大的列，在记录的真实数据处只会存储该列的一部分数据，把剩余的数据分散存储在几个其他的页中，然后记录的真实数据处用20个字节存储指向这些页的地址（当然这20个字节中还包括这些分散在其他页面中的数据的占用的字节数）。
21. 一个页一般是16KB，当记录中的数据太多，当前页放不下的时候，会把多余的数据存储到其他页中，这种现象称为**行溢出**。
22. Redundant行格式中，当某列数据非常长时，该行只会记录该列前*768字节*的数据，然后记录溢出页的地址。

   ![Redundant存储行数据](/assets/images/note/mysql/m-6.png)

   ![Redundant行格式](/assets/images/note/mysql/m-7.png)

23. 不只是`VARCHAR(M)`类型的列，其他的`TEXT`、`BLOB`类型的列在存储数据非常多的时候也会发生行溢出。
24. MySQL中要求一个页至少存储两行记录。
25. MySQL 5.7、8默认行格式是**Dynamic**。
26. **Dynamic**和**Compressed**行格式会把所有行溢出数据存储到其他页，原页面只记录页地址。**Compressed**会对页数据进行压缩。

## 第五章

1. 页是InnoDB管理存储空间的基本单位。
2. MySQL中有许多不同类型的页。

   ![Index索引页结构](/assets/images/note/mysql/m-8.png)

| 名称                     | 中文名               | 占用空间大小 | 简单描述                     |
|------------------------|--------------------|------------|-----------------------------|
| File Header            | 文件头部           | 38字节     | 页的一些通用信息             |
| Page Header            | 页面头部           | 56字节     | 数据页专有的一些信息         |
| Infimum + Supremum     | 最小记录和最大记录 | 26字节     | 两个虚拟的行记录             |
| User Records           | 用户记录           | 不确定     | 实际存储的行记录内容         |
| Free Space             | 空闲空间           | 不确定     | 页中尚未使用的空间           |
| Page Directory         | 页面目录           | 不确定     | 页中的某些记录的相对位置     |
| File Trailer           | 文件尾部           | 8字节      | 校验页是否完整               |

3. 我们自己插入的记录会以我们设置好的行格式存储在User Records的部分。User Records起初不存在，每当插入数据时会从Free Space中申请。Free Space使用完即页使用完了。

   ![记录在Index索引页中的存储](/assets/images/note/mysql/m-9.png)

4. 当表有主键时，一行记录不会生成row_id，而是把原来row_id的位置存储主键那一列的数据。
5. User Records中记录的存储格式如下（记录本身的信息进行了省略，只显示了记录头和数据部分）：

   ![记录在Index索引页中的存储 2](/assets/images/note/mysql/m-10.png)

6. 当记录被删除时，记录头中的delete_mask将会从0置1，但是实际上并不会从磁盘上立刻删除，而是生成了一个“垃圾链表”，垃圾链表上的记录构成一个可重用空间，当有新纪录进来时会将数据覆盖到这个可重用空间上。
7. heap_no 记录位置从2开始。0和1由两条隐藏记录`最小记录`和`最大记录`占用。
8. 最小记录和最大记录都由5B的记录头和8B的固定部分组成：

   ![最小记录和最大记录构成](/assets/images/note/mysql/m-11.png)

9. record_type为记录的类型，0为普通记录，1为B+树非叶子节点记录，2为最小记录，3为最大记录。
10. next_record为当前记录到下一条记录的偏移量。通过该值，从最小记录开始，经过用户记录，到最大记录结束，构成了一个单向链表。

   ![记录链表](/assets/images/note/mysql/m-12.png)

11. 删除记录的步骤：
- 将被删除记录的delete_mask置为1
- 将上一条记录的值的next_record值指向被删除记录的下一条记录
- 将被删除记录的next_record置为0
- 最大记录的n_owned值减1

可以参考单向链表删除节点的方法

12. 不论我们怎么对页中的记录做增删改操作，InnoDB始终会维护一条记录的单链表，链表中的各个节点是按照主键值由小到大的顺序连接起来的。
13. 把页中所有正常的记录划分为几个组，每个组中的最后一条记录的n_owned代表`该记录拥有多少条记录`，即`该组拥有多少条记录`。将每一组中最后一条记录的地址偏移量统一保存到页尾部的一个位置，这个偏移量被成为`Slot槽`，组成的部分即为页目录.
14. 对于最小记录所在的分组只能有 1 条记录，最大记录所在的分组拥有的记录条数只能在 1~8 条之间，剩下的分组中记录的条数范围只能在是 4~8 条之间。
15. 记录分组步骤如下：
- 初始只有最小记录和最大记录两个分组。
- 之后每插入一条记录，就会找到主键值大于要插入记录且差值最小的一个槽，将槽对应的n_owned记录加1，表示新增一条记录，直到该分组记录数量达到8。
- 在分组记录数达到8后，再添加一条记录，会将该分组拆分为大小分别为4和5的两个分组。此时会新增一个槽用于记录新增分组最后一条记录（最大记录）的偏移量。

16. 根据主键值查找记录时，会通过二分法（用的还是双指针）找到对应记录所在的槽，然后再通过next_record遍历这个槽来找到对应的记录。
17. Page Header页头用于记录页面中的状态信息，固定56个字节：

| 名称                  | 占用空间大小 | 描述                                                                                       |
|---------------------|-------------|------------------------------------------------------------------------------------------|
| PAGE_N_DIR_SLOTS    | 2字节        | 在页目录中的槽数量                                                                         |
| PAGE_HEAP_TOP       | 2字节        | 还未使用的空间最小地址，也就是说从该地址之后就是Free Space                             |
| PAGE_N_HEAP         | 2字节        | 本页中的记录的数量（包括最小和最大记录以及标记为删除的记录）                             |
| PAGE_FREE           | 2字节        | 第一个已经标记为删除的记录地址（各个已删除的记录通过next_record也会组成一个单链表，这个单链表中的记录可以被重新利用） |
| PAGE_GARBAGE        | 2字节        | 已删除记录占用的字节数                                                                     |
| PAGE_LAST_INSERT     | 2字节        | 最后插入记录的位置                                                                         |
| PAGE_DIRECTION      | 2字节        | 记录插入的方向                                                                             |
| PAGE_N_DIRECTION    | 2字节        | 一个方向连续插入的记录数量                                                                 |
| PAGE_N_RECS         | 2字节        | 该页中记录的数量（不包括最小和最大记录以及被标记为删除的记录）                           |
| PAGE_MAX_TRX_ID     | 8字节        | 修改当前页的最大事务ID，该值仅在二级索引中定义                                             |
| PAGE_LEVEL          | 2字节        | 当前页在B+树中所处的层级                                                                   |
| PAGE_INDEX_ID       | 8字节        | 索引ID，表示当前页属于哪个索引                                                              |
| PAGE_BTR_SEG_LEAF   | 10字节       | B+树叶子段的头部信息，仅在B+树的Root页定义                                                |
| PAGE_BTR_SEG_TOP    | 10字节       | B+树非叶子段的头部信息，仅在B+树的Root页定义                                             |

18. PAGE_DIRECTION用来表示最后一条记录插入的方向，若新的一条记录的主键值比上一条插入的记录大，则插入方向为右边，否则为左边。
19. Page Header针对InnoDB的Index页记录各种信息，而File Header记录的是所有类型的页通用的信息，固定38个字节：

| 名称                                  | 占用空间大小 | 描述                                                                                      |
|-------------------------------------|-------------|-----------------------------------------------------------------------------------------|
| FIL_PAGE_SPACE_OR_CHKSUM            | 4字节        | 页的校验和（checksum值）                                                                |
| FIL_PAGE_OFFSET                      | 4字节        | 页号                                                                                    |
| FIL_PAGE_PREV                        | 4字节        | 上一个页的页号                                                                          |
| FIL_PAGE_NEXT                        | 4字节        | 下一个页的页号                                                                          |
| FIL_PAGE_LSN                         | 8字节        | 页面被最后修改时对应的日志序列位置（英文名是：Log Sequence Number）                      |
| FIL_PAGE_TYPE                        | 2字节        | 该页的类型                                                                              |
| FIL_PAGE_FILE_FLUSH_LSN             | 8字节        | 仅在系统表空间的一个页中定义，代表文件至少被刷新到了对应的LSN值                      |
| FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID     | 4字节        | 页属于哪个表空间                                                                        |

20. 每一个页都有单独、唯一的一个页号。
21. 页类型如下：

| 类型名称                           | 十六进制   | 描述                     |
|----------------------------------|-----------|------------------------|
| FIL_PAGE_TYPE_ALLOCATED          | 0x0000    | 最新分配，还没使用       |
| FIL_PAGE_UNDO_LOG                | 0x0002    | Undo日志页              |
| FIL_PAGE_INODE                   | 0x0003    | 段信息节点              |
| FIL_PAGE_IBUF_FREE_LIST          | 0x0004    | Insert Buffer空闲列表   |
| FIL_PAGE_IBUF_BITMAP             | 0x0005    | Insert Buffer位图       |
| FIL_PAGE_TYPE_SYS                | 0x0006    | 系统页                  |
| FIL_PAGE_TYPE_TRX_SYS            | 0x0007    | 事务系统数据            |
| FIL_PAGE_TYPE_FSP_HDR            | 0x0008    | 表空间头部信息          |
| FIL_PAGE_TYPE_XDES               | 0x0009    | 扩展描述页              |
| FIL_PAGE_TYPE_BLOB               | 0x000A    | BLOB页                  |
| FIL_PAGE_INDEX                   | 0x45BF    | 索引页，也就是我们所说的数据页 |

22. 并非所有类型的页都有`FIL_PAGE_PREV`和`FIL_PAGE_NECT`属性。
23. File Trailer固定由8个字节组成，前4个字节代表页的校验和，后4个字节代表页面被最后修改时对应的日志序列位置（LSN）。
24. File Trailer所有类型的页通用。

## 第六章

1. 在无索引且以非主键列为条件的查找中，查询过程是从第一页按顺序进行，效率较低。
2. 新插入数据分配的页号不一定与上一条数据分配的页号连续，页与页之间以双向链表的形式连接，因此在物理存储上不一定连续。
3. 记录头信息中的 `record_type` 为 1 的是目录项记录。
4. 目录项记录仅包含主键值和页的编号两个列，而普通的用户记录的列是用户自定义的，可能包含多个列，此外还有 InnoDB 自己添加的隐藏列。
5. 只有在存储目录项记录的页中，主键值最小的目录项记录的 `min_rec_mask` 值为 1，其他记录的 `min_rec_mask` 值均为 0。
6. 存储目录项记录的页和存储用户记录的页是相互独立的，不会混合存储两种记录。

   ![目录项记录结构](/assets/images/note/mysql/m-14.png)

   ![B+树结构](/assets/images/note/mysql/m-15.png)

   实际用户记录存放在 B+ 树的最底层节点上，这些节点称为叶子节点或叶节点，其余用来存放目录项的节点称为非叶子节点或内节点，其中 B+ 树最上面的节点称为根节点。

7. 拥有以下特性的 B+ 树称为 **聚簇索引**：

   - 使用记录主键值的大小进行记录和页的排序，包括三个方面的含义：
     - 页内的记录按照主键的大小顺序排成一个单向链表。
     - 各个存放用户记录的页根据页中用户记录的主键大小顺序排成一个双向链表。
     - 存放目录项记录的页分为不同的层次，在同一层次中的页也根据页中目录项记录的主键大小顺序排成一个双向链表。

   - B+ 树的叶子节点存储完整的用户记录。

   这种聚簇索引不需要在 MySQL 语句中显式使用 `INDEX` 语句去创建（后面会介绍索引相关的语句），InnoDB 存储引擎会自动为我们创建聚簇索引。另一个有趣的点是，在 InnoDB 存储引擎中，聚簇索引就是数据的存储方式（所有用户记录都存储在了叶子节点），也就是所谓的“索引即数据，数据即索引”。

8. 聚簇索引只有在搜索条件为主键时才有效。
9. 二级索引 / 辅助索引的特点如下：
   - 使用记录 `c2` 列的大小进行记录和页的排序，包括三个方面的含义：
     - 页内的记录按照 `c2` 列的大小顺序排成一个单向链表。
     - 各个存放用户记录的页根据页中记录的 `c2` 列大小顺序排成一个双向链表。
     - 存放目录项记录的页分为不同的层次，在同一层次中的页也根据页中目录项记录的 `c2` 列大小顺序排成一个双向链表。

   - B+ 树的叶子节点存储的不是完整的用户记录，而仅包含 `c2` 列和主键这两个列的值。

   - 目录项记录中不再是主键 + 页号的搭配，而变成了 `c2` 列 + 页号的搭配。

10. 通过二级索引查找目标记录的步骤如下：
    - 确定目录项记录页
    - 通过目录项记录页确定用户记录真实所在的页
    - 在真实存储用户记录的页中定位到具体的记录
    - 由于 B+ 树的叶子节点中的记录只存储了 `c2` 和 `c1`（即主键）两个列，因此必须根据主键值再去聚簇索引中查找完整的用户记录。

    这个过程称为 **回表**。

11. 联合索引是以多列的值的大小排序建立 B+ 树，本质上也是二级索引，区别在于只会生成一棵 B+ 树。
12. 一个 B+ 树索引的根节点自诞生之日起，便不会再移动。最开始表只有一个节点，不断向其中添加记录，超出大小上限时，其数据会先分配到一个新的页，然后该新页进行 **页分裂**，分出另一个新页，将数据按相关索引列值大小排序分配到不同的页上，原来的节点升级为这两个页的根节点。此后每当 InnoDB 需要用到该索引时，会从固定的节点中取出该索引。
13. 为了让新插入记录能找到自己在那个页里，需要保证在 B+ 树的同一层内节点的目录项记录除页号字段外是唯一的。因此，二级索引的内节点的目录项记录实际上由三个部分构成：
    - 索引列的值
    - 主键值
    - 页号

    此时列值相同时通过比较主键值进行排序。

14. 在 MyISAM 中，索引和用户记录完全独立存储。先将用户记录存储到一张列表中，然后建立一张主键 -> 行号的索引，通过索引找到行号，再根据行号找到实际记录，因此 MyISAM 中的索引全都是二级索引。
15. MyISAM 中对其他列建立索引的原理与 InnoDB 中类似，在叶子节点处存储的是相应列值 + 行号。
